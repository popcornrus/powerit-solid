## Single-Responsibility Principle (Принцип единственной ответственности)

> *«Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.»*

Представьте себе класс, который составляет и печатает отчёт (ComposeAndPrintOrder). Такой класс может измениться по двум причинам:
* может измениться само содержимое отчёта
* может измениться формат отчёта.

Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. SRP говорит, что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна ответственность. Причина, почему нужно сохранять направленность классов на единственную цель в том, что это делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в процессе составления отчёта — есть большая вероятность, что в негодность придёт код, отвечающий за печать.

**Пример неправильного использования SPR:**
https://github.com/popcornrus/powerit-solid/blob/main/SRP/IncorrectSPR.php
**Пример корректного применения SPR:**
https://github.com/popcornrus/powerit-solid/blob/main/SRP/CorrectSPR.php

![image](https://user-images.githubusercontent.com/32881606/216320479-900b8a2a-1ffa-4123-9e04-3489fd40e733.png)

## Open–closed Principle (Принцип открытости-закрытости)

> *«Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения»*

Как известно программные проекты в течение свой жизни постоянно изменяются. Изменения могут возникнуть, например, из-за новых требований заказчика или пересмотра старых. В конечном итоге потребуется изменить код в соответствии с текущей ситуацией.

С одной стороны внесение изменений требует времени программистов и тестировщиков, которое является очень дорогим ресурсом в производстве ПО. С другой, бизнес должен достаточно быстро реагировать на рыночные изменения и время здесь представляется очень важным конкурентным преимуществом.
Принцип открытости/закрытость как раз и дает понимание того, как оставаться достаточно гибкими в условиях постоянно меняющихся требований.

**Пример неправильного использования OCP:**
https://github.com/popcornrus/powerit-solid/blob/main/OCP/IncorrectOCP.php
**Пример корректного применения OCP:**
https://github.com/popcornrus/powerit-solid/blob/main/OCP/CorrectOCP.php

![image](https://user-images.githubusercontent.com/32881606/216320560-ccce8622-7420-4c69-881d-f325fe076c18.png)

## Liskov substitution Principle (Принцип подстановки Барбары Лисков)

> *«Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.»*

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.

Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу.

**Пример неправильного использования LSP:**
https://github.com/popcornrus/powerit-solid/blob/main/LSP/IncorrectLSP.php
**Пример корректного применения LSP:**
https://github.com/popcornrus/powerit-solid/blob/main/LSP/CorrectLSP.php

![image](https://user-images.githubusercontent.com/32881606/216320637-a666dd33-e2e0-4afd-ab30-abd5d5b12c82.png)

## Interface Segregation Principle (Принцип разделения интерфейса)

> *«Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения»*

Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.
Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

**Пример неправильного использования ISP:**
https://github.com/popcornrus/powerit-solid/blob/main/ISP/IncorrectISP.php
**Пример корректного применения ISP:**
https://github.com/popcornrus/powerit-solid/blob/main/ISP/CorrectISP.php

![image](https://user-images.githubusercontent.com/32881606/216320671-489a5442-1ae0-46dc-bee1-723a086925ef.png)

## Dependency Inversion Principle (Принцип инверсии зависимостей)

> *«Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.»*

Согласно данному принципу, класс не должен соединяться с инструментом, который применяется для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.  
Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.

**Пример неправильного использования DIP:**
https://github.com/popcornrus/powerit-solid/blob/main/DIP/IncorrectDIP.php
**Пример корректного применения DIP:**
https://github.com/popcornrus/powerit-solid/blob/main/DIP/CorrectDIP.php

![image](https://user-images.githubusercontent.com/32881606/216320701-70cf7788-9773-417f-90be-8770e27b9111.png)
